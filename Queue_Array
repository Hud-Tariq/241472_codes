#include <iostream>
#include <stdexcept>
using namespace std;

class Queue {
private:
    int queue_size;
    int ifront;
    int iback;
    int array_capacity;
    int* array;
void double_capacity() {
    int* new_array = new int[array_capacity * 2];

    int i = ifront;

    for (int count = 0; count < queue_size; count++) {
        new_array[count] = array[i];
        i++;

        // Manual wrap-around
        if (i == array_capacity) {
            i = 0;
        }
    }

    delete[] array;

    array = new_array;
    array_capacity *= 2;
    ifront = 0;
    iback = queue_size - 1;
}


public:
    Queue(int n = 5)
        : queue_size(0),
          ifront(0),
          iback(-1),
          array_capacity(n),
          array(new int[array_capacity]) {}

    ~Queue() {
        delete[] array;
    }

    bool empty() const {
        return queue_size == 0;
    }

    int front() const {
        if (empty())
            throw underflow_error("Queue Underflow");
        return array[ifront];
    }

    void push(int x) {
        if (queue_size == array_capacity)
            double_capacity();

        iback = (iback + 1) % array_capacity;
        array[iback] = x;
        queue_size++;
    }

    int pop() {
        if (empty())
            throw underflow_error("Queue Underflow");

        int value = array[ifront];
        ifront = (ifront + 1) % array_capacity;
        queue_size--;
        return value;
    }
};

// ---------------- MAIN FUNCTION ----------------
int main() {
    Queue q(4);

    q.push(10);
    q.push(20);
    q.push(30);
    q.push(40);

    // This push forces normalization + doubling
    q.push(50);

    while (!q.empty()) {
        cout << q.pop() << " ";
    }

    return 0;
}
