#include <iostream>
#include <stdexcept>
using namespace std;

class Queue {
private:
    int queue_size;
    int ifront;
    int iback;
    int array_capacity;
    int* array;

    // Easier-to-understand normalized doubling
    void double_capacity() {
        int* new_array = new int[array_capacity * 2];

        // Copy elements in FIFO order
        int j = 0;
        for (int i = ifront; j < queue_size; i = (i + 1) % array_capacity) {
            new_array[j++] = array[i];
        }

        delete[] array;

        array = new_array;
        array_capacity *= 2;
        ifront = 0;
        iback = queue_size - 1;
    }

public:
    Queue(int n = 5)
        : queue_size(0),
          ifront(0),
          iback(-1),
          array_capacity(n),
          array(new int[array_capacity]) {}

    ~Queue() {
        delete[] array;
    }

    bool empty() const {
        return queue_size == 0;
    }

    int front() const {
        if (empty())
            throw underflow_error("Queue Underflow");
        return array[ifront];
    }

    void push(int x) {
        if (queue_size == array_capacity)
            double_capacity();

        iback = (iback + 1) % array_capacity;
        array[iback] = x;
        queue_size++;
    }

    int pop() {
        if (empty())
            throw underflow_error("Queue Underflow");

        int value = array[ifront];
        ifront = (ifront + 1) % array_capacity;
        queue_size--;
        return value;
    }
};

// ---------------- MAIN FUNCTION ----------------
int main() {
    Queue q(4);

    q.push(10);
    q.push(20);
    q.push(30);
    q.push(40);

    // This push forces normalization + doubling
    q.push(50);

    while (!q.empty()) {
        cout << q.pop() << " ";
    }

    return 0;
}
