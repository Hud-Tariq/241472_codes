#include <iostream>
#include <algorithm> // For std::max
#include <stdexcept> // For std::underflow_error, std::out_of_range

using namespace std;

// ==========================================
// 1. Binary Search Node Class
// ==========================================
template <typename Type>
class Binary_search_node {
private:
    Type element;
    Binary_search_node *left_tree;
    Binary_search_node *right_tree;

public:
    // --- Constructor ---
    Binary_search_node(Type const &obj) 
        : element(obj), left_tree(nullptr), right_tree(nullptr) {}

    // --- Accessors ---
    Type retrieve() const { return element; }
    Binary_search_node* left() const { return left_tree; }
    Binary_search_node* right() const { return right_tree; }

    // --- Status ---
    bool empty() const { return (this == nullptr); }
    bool is_leaf() const { return !empty() && left()->empty() && right()->empty(); }

    // --- Metrics ---
    int size() const {
        return empty() ? 0 : 1 + left()->size() + right()->size();
    }

    int height() const {
        return empty() ? -1 : 1 + std::max(left()->height(), right()->height());
    }

    // --- Operations (Recursive) ---
    
    // Find Kth Value (New Implementation)
    Type find_kth(int k) const {
        int left_size = (left() != nullptr) ? left()->size() : 0;
        
        // Case 1: The kth item is in the left subtree
        if (k <= left_size) {
            return left()->find_kth(k);
        }
        // Case 2: The kth item is THIS node (left_size + 1)
        else if (k == left_size + 1) {
            return retrieve();
        }
        // Case 3: The kth item is in the right subtree
        else {
            return right()->find_kth(k - left_size - 1);
        }
    }

    // Insert
    bool insert(Type const &obj, Binary_search_node *&ptr_to_this) {
        if (empty()) {
            ptr_to_this = new Binary_search_node<Type>(obj);
            return true;
        } else if (obj < retrieve()) {
            return left()->insert(obj, left_tree);
        } else if (obj > retrieve()) {
            return right()->insert(obj, right_tree);
        }
        return false; // Duplicate
    }

    // Erase
    bool erase(Type const &obj, Binary_search_node *&ptr_to_this) {
        if (empty()) return false;
        
        if (obj < retrieve()) {
            return left()->erase(obj, left_tree);
        } else if (obj > retrieve()) {
            return right()->erase(obj, right_tree);
        } else {
            // Found node to delete
            if (is_leaf()) {
                delete this;
                ptr_to_this = nullptr;
            } else if (!left()->empty() && !right()->empty()) {
                // Two children: Swap with min of right subtree
                element = right()->front();
                right()->erase(retrieve(), right_tree);
            } else {
                // One child
                Binary_search_node<Type> *temp = (!left()->empty()) ? left() : right();
                ptr_to_this = temp; // Re-link parent to child
                
                // Safety detach to prevent recursive delete issues
                left_tree = nullptr; 
                right_tree = nullptr;
                delete this;
            }
            return true;
        }
    }

    // Clear
    void clear(Binary_search_node<Type> *ptr_to_this) {
        if (empty()) return;
        left()->clear(left_tree);
        right()->clear(right_tree);
        delete this;
    }

    // Min/Max Helpers
    Type front() const {
        if (empty()) throw underflow_error("Tree is empty");
        return (left()->empty()) ? retrieve() : left()->front();
    }

    Type back() const {
        if (empty()) throw underflow_error("Tree is empty");
        return (right()->empty()) ? retrieve() : right()->back();
    }
    
    // Find Helper
    bool find(Type const &obj) const {
        if (empty()) return false;
        if (obj == retrieve()) return true;
        return (obj < retrieve()) ? left()->find(obj) : right()->find(obj);
    }
};

// ==========================================
// 2. Binary Search Tree Class
// ==========================================
template <typename Type>
class Binary_search_tree {
private:
    Binary_search_node<Type> *root_node;

public:
    Binary_search_tree() : root_node(nullptr) {}
    ~Binary_search_tree() { clear(); }

    // --- Basics ---
    bool empty() const { return (root_node == nullptr); }
    int size() const { return (root_node == nullptr) ? 0 : root_node->size(); }
    int height() const { return (root_node == nullptr) ? -1 : root_node->height(); }
    void clear() { if (root_node) { root_node->clear(root_node); root_node = nullptr; } }
    
    // --- Core Operations ---
    bool insert(Type const &obj) { return root_node->insert(obj, root_node); }
    bool erase(Type const &obj) { return root_node->erase(obj, root_node); }
    bool contains(Type const &obj) const { return (root_node == nullptr) ? false : root_node->find(obj); }
    
    // --- Min / Max ---
    Type min() const { return root_node->front(); }
    Type max() const { return root_node->back(); }

    // ==========================================
    // NEW: RELATION-BASED OPERATIONS
    // ==========================================

    // 1. Find the Kth Smallest Value (1-based index)
    Type kth_value(int k) const {
        if (root_node == nullptr || k < 1 || k > size()) {
            throw out_of_range("k is out of valid range");
        }
        return root_node->find_kth(k);
    }

    // 2. Find Next (Successor)
    // Returns the smallest value strictly greater than 'obj'
    Type find_next(Type const &obj) const {
        Binary_search_node<Type>* current = root_node;
        Binary_search_node<Type>* successor = nullptr;

        while (current != nullptr) {
            if (obj < current->retrieve()) {
                // 'current' is bigger than 'obj', so it's a candidate for "Next"
                successor = current;
                current = current->left(); // Try to find a smaller "Next"
            } else {
                // 'current' is <= 'obj', so it cannot be the "Next"
                current = current->right();
            }
        }

        if (successor == nullptr) throw out_of_range("No next value exists");
        return successor->retrieve();
    }

    // 3. Find Previous (Predecessor)
    // Returns the largest value strictly smaller than 'obj'
    Type find_prev(Type const &obj) const {
        Binary_search_node<Type>* current = root_node;
        Binary_search_node<Type>* predecessor = nullptr;

        while (current != nullptr) {
            if (obj > current->retrieve()) {
                // 'current' is smaller than 'obj', so it's a candidate for "Prev"
                predecessor = current;
                current = current->right(); // Try to find a larger "Prev"
            } else {
                // 'current' is >= 'obj', so it cannot be the "Prev"
                current = current->left();
            }
        }

        if (predecessor == nullptr) throw out_of_range("No previous value exists");
        return predecessor->retrieve();
    }
};

// ==========================================
// 3. Test Driver
// ==========================================
template <typename Type>
void print_inorder(Binary_search_node<Type>* node) {
    if (node) {
        print_inorder(node->left());
        cout << node->retrieve() << " ";
        print_inorder(node->right());
    }
}

int main() {
    Binary_search_tree<int> tree;

    // Building Tree: 42, 11, 70, 59, 51, 99
    // Structure:
    //      42
    //     /  \
    //   11    70
    //        /  \
    //       59   99
    //      /
    //     51

    tree.insert(42);
    tree.insert(11);
    tree.insert(70);
    tree.insert(59);
    tree.insert(51);
    tree.insert(99);

    cout << "Tree Values: 11 42 51 59 70 99" << endl;

    // --- Test Kth Value ---
    cout << "\n--- Testing Kth Value ---" << endl;
    cout << "1st Value (Min): " << tree.kth_value(1) << endl; // 11
    cout << "3rd Value: " << tree.kth_value(3) << endl;       // 51
    cout << "6th Value (Max): " << tree.kth_value(6) << endl; // 99

    // --- Test Previous / Next ---
    cout << "\n--- Testing Next/Prev ---" << endl;
    
    // Find Next of 51 (should be 59)
    cout << "Next after 51: " << tree.find_next(51) << endl;
    
    // Find Next of 42 (should be 51)
    cout << "Next after 42: " << tree.find_next(42) << endl;

    // Find Prev of 59 (should be 51)
    cout << "Prev before 59: " << tree.find_prev(59) << endl;

    // Find Next of something NOT in the tree (e.g., 60)
    // The next value after 60 should be 70
    cout << "Next after 60 (not in tree): " << tree.find_next(60) << endl;

    return 0;
}
